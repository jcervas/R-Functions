  is_minimum <- function(x,v) {
  # stopifnot(!is.numeric(x), "Not numeric")
  if (sum(x)<v) return(FALSE)
  for (k in 1:length(x)) {
    xx <- x[-k]
    ifelse(sum(xx)<v, next, return(FALSE))
  }
  return(TRUE)
}

# # Generated by ChatGPT
# # Define the weights and quota
# weights <- c(3, 5, 8, 13, 21, 34, 55)
# quota <- 70
# n <- length(weights)

# # Generate all possible subsets (excluding empty set)
# coalitions <- list()
# index <- 1

# for (k in 1:n) {
#   combs <- combn(n, k, simplify = FALSE)
#   for (combo in combs) {
#     w_sum <- sum(weights[combo])
#     if (w_sum >= quota) {
#       # Check if it's minimal: remove one player at a time and test if sum < quota
#       is_minimal <- TRUE
#       for (i in combo) {
#         subcombo <- setdiff(combo, i)
#         if (sum(weights[subcombo]) >= quota) {
#           is_minimal <- FALSE
#           break
#         }
#       }
#       if (is_minimal) {
#         coalitions[[index]] <- combo
#         index <- index + 1
#       }
#     }
#   }
# }

# # Print results
# cat("Minimum winning coalitions (as indices of weights):\n")
# for (coal in coalitions) {
#   cat("{", paste(coal, collapse = ", "), "} -> weights: {", paste(weights[coal], collapse = ", "), "}\n")
# }
